/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/Iplb.ycp
 * Package:	Configuration of iplb
 * Summary:	Iplb settings, input and output functions
 * Authors:	Cong Meng <cmeng@novell.com>
 *
 * $Id: Iplb.ycp 41350 2007-10-10 16:59:00Z dfiser $
 *
 * Representation of the configuration of iplb.
 * Input and output routines.
 */

{

module "Iplb";
textdomain "iplb";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "IP";
 
// the global configure
global map<string, string> global_conf = $[];
// the virtual servers configure
global map<string, map>  vserver_conf = $[];


/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
boolean modified = false;

/**
 */
boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}

/**
 * Mark as modified, for Autoyast.
 */
global void SetModified() {
      modified = true;
}

global boolean ProposalValid() {
    return proposal_valid;
}

global void SetProposalValid(boolean value) {
    proposal_valid = value;
}

/**
 * @return true if module is marked as "write only" (don't start services etc...)
 */
global boolean WriteOnly() {
    return write_only;
}

/**
 * Set write_only flag (for autoinstalation).
 */
global void SetWriteOnly(boolean value) {
    write_only = value;
}


global void SetAbortFunction(boolean() function) {
    AbortFunction = function;
}



list<string> quote_list = [
	"callback",
	"logfile",
	"emailalert",
	"execute",
	"checkcommand",
	"request",
	"receive",
	"virtualhost",
	"login",
	"passwd",
	"database",
	"secret"
];


string remove_quote(string str)
{
	str = regexpsub(str, "^\"?(.*)", "\\1");
	if (regexpmatch(str, ".*\"$"))
		str = regexpsub(str, "^(.*)\"$", "\\1");
	return str;
}


void remove_global_conf_quote()
{
	foreach (string key, string val, global_conf, {
		if (contains(quote_list, key))
			global_conf[key] = remove_quote(global_conf[key]:"");
	});
}


void add_global_conf_quote()
{
	remove_global_conf_quote();
	foreach (string key, string val, global_conf, {
		if (contains(quote_list, key))
			global_conf[key] = "\"" + global_conf[key]:"" + "\"";
	});
}


void remove_vserver_conf_quote()
{
	foreach (string key1, map val1, vserver_conf, {
		foreach (string key2, list val2, (map<string, list>)val1, {
			if (contains(quote_list, key2)) {
				val2[0] = remove_quote(val2[0]:"");
				vserver_conf[key1, key2] = val2;
			};
		});
	});
}


void add_vserver_conf_quote()
{
	remove_vserver_conf_quote();
	foreach (string key1, map val1, vserver_conf, {
		foreach (string key2, list val2, (map<string, list>)val1, {
			if (contains(quote_list, key2)) {
				val2[0] = "\"" + val2[0]:"" + "\"";
				vserver_conf[key1, key2] = val2;
			};
		});
	});
}


/**
 * Read all iplb settings
 * @return true on success
 */
global boolean Read()
{
	list<string> pair_names = [];
    string caption = _("Initializing IPLB Configuration");

    // Names of real stages
    Progress::New(caption, " ", 3,
		[
		    _("Read the global settings"),
		    _("Read the virtual host settings")
		],
		[
		    _("Reading the global settings..."),
		    _("Reading the virtual host settings..."),
		    _("Finished")
		],
		""
    );

	/////////////////////////////////
	// read global configure
	/////////////////////////////////
	// dir all global configure names
	pair_names = SCR::Dir(.iplb.value);

	// read global configure values
	global_conf = $[];
	foreach (string key, pair_names, {
		list<string> vals = (list<string>) SCR::Read(.iplb.value + topath(key));
		global_conf[key] = vals[0]:"";
	});

	remove_global_conf_quote();

	y2debug("___iplbdebug___ read global_conf = %1", global_conf);
    Progress::NextStage();


	/////////////////////////////////
	// read vservers configure
	/////////////////////////////////
	// dir all vserver names
	list<string> vserver_names = SCR::Dir(.iplb.section);

	// iterate all vserver names
	foreach (string vs_name, vserver_names, {
		vserver_conf[vs_name] = $[];
		// vserver name contains ".", so quote it
		path vs_name_path = topath("\"" + vs_name + "\"");

		// dir all pair name of given vserver name
		pair_names = (list<string>) SCR::Dir(.iplb.value + vs_name_path);
		// iterate pair names to read the pair value
		foreach (string key, pair_names, {
			vserver_conf[vs_name, key] = SCR::Read(.iplb.value + vs_name_path + topath(key));
		});
		//check for IPv6 address
		boolean is_ipv6=false;
  	        path sect_path=topath("");
	        string ipv6_address=regexpsub(vs_name,"\\[(.+)\\]","\\1");
	        if(ipv6_address!=nil)
		  is_ipv6=IP::Check6(ipv6_address);
		if(is_ipv6){
		  if(vserver_conf[vs_name,"real6"]:[] != []){
		    vserver_conf[vs_name,"real"]=vserver_conf[vs_name,"real6"]:[];
		    vserver_conf[vs_name,"real6"]=[];
		  }
		  if(vserver_conf[vs_name,"fallback6"]:[] != []){
		    vserver_conf[vs_name,"fallback"]=vserver_conf[vs_name,"fallback6"]:[];
		    vserver_conf[vs_name,"fallback6"]=[];
		  }
		}

	});

	remove_vserver_conf_quote();

	y2debug("___iplbdebug___ read vserver_conf = %1", vserver_conf);
    Progress::NextStage();

    /* Progress finished */
    Progress::NextStage();

    modified = false;
    return true;
}

/**
 * Write all iplb settings
 * @return true on success
 */
global boolean Write()
{
	boolean ret = false;
    string caption = _("Saving IPLB Configuration");

    Progress::New(caption, " ", 2, [
	    _("Write the settings"),
	    _("Run SuSEconfig")
	], [
	    _("Writing the settings..."),
	    _("Running SuSEconfig..."),
	    _("Finished")
	],
	""
    );

	// remove all sections, as ini agent will write new global conf
	// entry at the end of the conf file. (global conf after sections
	// will be read as vserver conf, not as global conf. it's a bug)
	foreach(string key, map val, vserver_conf, {
		path sect_path = topath("\"" + key + "\"");
		ret = SCR::Write(.iplb.section + sect_path, nil);
	});

	map<string, string> saved_global_conf = global_conf;
	add_global_conf_quote();

    // write global conf
	y2debug("___iplbdebug___ write global_conf=%1", global_conf);
	foreach (string key, string val, global_conf, {
		list write_val = nil;
		if (val != nil) write_val = [val];
		ret = SCR::Write(.iplb.value + topath(key), write_val);
		if (!ret) Report::Error (_("Cannot write settings."));
	});
    Progress::NextStage();

	global_conf = saved_global_conf;


	map<string, map> saved_vserver_conf = vserver_conf;
	add_vserver_conf_quote();

	// write vserver conf
	y2debug("___iplbdebug___ write vserver_conf=%1", vserver_conf);
	foreach(string key, map val, vserver_conf, {
	        /*check for ipv6 address to decide whether to add "6=" or "="*/
		/* string key's format
		 * 192.168.6.241:89 or [2001:db8::5]:119
		 * only extract the 2001:db8::5 part from the key string
		 * to check whether it is an ipv6 address;
		 */
	        boolean is_ipv6=false;
  	        path sect_path=topath("");
	        string ipv6_address=regexpsub(key,"\\[(.+)\\]","\\1");
	        if(ipv6_address!=nil)
		{
		  is_ipv6=IP::Check6(ipv6_address);
		}

		if(is_ipv6){
		  sect_path = topath("\"6 = " + key + "\"");
		  if(val["fallback"]:[] != []){
		    val["fallback6"]=val["fallback"]:[];
		    val["fallback"]=[];
		  }
		  if(val["real"]:[] != []){
		    val["real6"]=val["real"]:[];
		    val["real"]=[];
		  }
		}
		else
		  sect_path = topath("\" = "  + key + "\"");
		
		if (val == nil) {
			ret = SCR::Write(.iplb.section + sect_path, nil);
			if (!ret) Report::Error(_("Cannot write settings."));
			continue;
		}

		foreach(string key1, list val1, (map<string, list>)val, {
			ret = SCR::Write(.iplb.value + sect_path + topath(key1), val1);
			if (!ret) Report::Error(_("Cannot write settings."));
		});
	});
    Progress::NextStage();

	vserver_conf = saved_vserver_conf;

    /* Progress finished */
    Progress::NextStage();

    return true;
}

/**
 * Get all iplb settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the iplb settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    // TODO FIXME: your code here (return the above mentioned variables)...
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    // TODO FIXME: your code here...
    /* Configuration summary text for autoyast */
    return [ _("Configuration summary..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    // TODO FIXME: your code here...
    return $[ "install":[], "remove":[] ];
}

/* EOF */
}
